/* * Copyright (c) 2015 Samsung Electronics Co., Ltd. All rights reserved.  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that  * the following conditions are met: *  *     * Redistributions of source code must retain the above copyright notice,  *       this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright notice,  *       this list of conditions and the following disclaimer in the documentation and/or  *       other materials provided with the distribution.  *     * Neither the name of Samsung Electronics Co., Ltd. nor the names of its contributors may be used to endorse *       or promote products derived from this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */package com.jhb.dvt.dvt_store.Services;import android.content.Intent;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Matrix;import android.os.AsyncTask;import android.os.Binder;import android.os.Handler;import android.os.HandlerThread;import android.os.IBinder;import android.os.Looper;import android.provider.MediaStore;import android.support.v4.os.AsyncTaskCompat;import android.util.Base64;import android.util.Log;import android.util.SparseArray;import android.widget.Toast;import com.bumptech.glide.Glide;import com.jhb.dvt.dvt_store.Constants.Constants;import com.jhb.dvt.dvt_store.Models.Item;import com.jhb.dvt.dvt_store.Services.ImageFetchModelImpl.ImgReqMsg;import com.jhb.dvt.dvt_store.Services.ImageFetchModelImpl.ImgRespMsg;import com.jhb.dvt.dvt_store.Services.ImageFetchModelImpl.TBListReqMsg;import com.jhb.dvt.dvt_store.Services.ImageFetchModelImpl.TBListRespMsg;import com.jhb.dvt.dvt_store.Services.ImageFetchModelImpl.TBModelJson;import com.jhb.dvt.dvt_store.Utils.Utilities;import com.samsung.android.sdk.SsdkUnsupportedException;import com.samsung.android.sdk.accessory.SA;import com.samsung.android.sdk.accessory.SAAgent;import com.samsung.android.sdk.accessory.SAPeerAgent;import com.samsung.android.sdk.accessory.SASocket;import org.json.JSONException;import org.json.JSONObject;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.concurrent.ExecutionException;public class GalleryProviderService extends SAAgent {    private static final String TAG = "GalleryProviderService";    private static final int GALLERY_CHANNEL_ID = 104;    private static final Class<GalleryProviderConnection> SASOCKET_CLASS = GalleryProviderConnection.class;    private SA mAccessory;    private final IBinder mBinder = new LocalBinder();    private HandlerThread mThread;    private Looper mLooper;    private Handler mBackgroundHandler;    private String mResult = "failure";    private static final int INITIAL_IMAGE_INDEX = -1;    private static final int REASON_OK = 0;    private static final int REASON_IMAGE_ID_INVALID = 2;    private static final int REASON_EOF_IMAGE = 3;    private static final int REASON_DATABASE_ERROR = 4;    final List<Item> featured = new ArrayList<>();    final List<Integer> Sizes = new ArrayList<>();    private int mReason = REASON_IMAGE_ID_INVALID;    String[] mProjection = {                MediaStore.Images.Media._ID,                MediaStore.Images.Media.DATA,                MediaStore.Images.Media.SIZE,                MediaStore.Images.Media.DISPLAY_NAME,                MediaStore.Images.Media.WIDTH,                MediaStore.Images.Media.HEIGHT    };    SparseArray<GalleryProviderConnection> mConnectionsMap = null;    String mImgData = "";    List<TBModelJson> mTb = new ArrayList<>();    public GalleryProviderService() {        super(TAG, SASOCKET_CLASS);    }    @Override    public void onCreate() {        super.onCreate();        mAccessory = new SA();        try {            mAccessory.initialize(this);        } catch (SsdkUnsupportedException e) {            if (processUnsupportedException(e) == true) {                return;            }        } catch (Exception e1) {            e1.printStackTrace();            stopSelf();        }        mThread = new HandlerThread("GalleryProvider");        mThread.start();        mLooper = mThread.getLooper();        if (mLooper != null) {            mBackgroundHandler = new Handler(mLooper);        } else {            throw new RuntimeException("Could not get Looper from Handler Thread");        }    }    @Override    public IBinder onBind(Intent intent) {        return mBinder;    }    @Override    public void onLowMemory() {        closeConnection();        super.onLowMemory();    }    @Override    public void onDestroy() {        super.onDestroy();        mAccessory = null;    }    public boolean closeConnection() {        if (mConnectionsMap != null) {            final List<Integer> listConnections = new ArrayList<Integer>(mConnectionsMap.size());            for (final Integer s : listConnections) {                mConnectionsMap.get(s).close();                mConnectionsMap.remove(s);            }        }        return true;    }    @Override    protected void onServiceConnectionResponse(SAPeerAgent peerAgent, SASocket socket, int result) {        if (result == CONNECTION_SUCCESS && socket != null) {            final GalleryProviderConnection myConnection = (GalleryProviderConnection) socket;            if (mConnectionsMap == null) {                mConnectionsMap = new SparseArray<GalleryProviderConnection>();            }            myConnection.mConnectionId = (int) (System.currentTimeMillis() & 255);            mConnectionsMap.put(myConnection.mConnectionId, myConnection);            mBackgroundHandler.post(new Runnable() {                @Override                public void run() {                    Toast.makeText(getBaseContext(),"connected", Toast.LENGTH_SHORT).show();                }            });        }    }    @Override    protected void onFindPeerAgentsResponse(SAPeerAgent[] peerAgents, int result) {    }    @Override    protected void onPeerAgentsUpdated(SAPeerAgent[] peerAgents, int result) {    }    @Override    protected void onError(SAPeerAgent peerAgent, String error, int errorCode) {        Log.e(TAG, "ERROR: " + errorCode + ": " + error);    }    private boolean processUnsupportedException(SsdkUnsupportedException e) {        e.printStackTrace();        int errType = e.getType();        if (errType == SsdkUnsupportedException.VENDOR_NOT_SUPPORTED                    || errType == SsdkUnsupportedException.DEVICE_NOT_SUPPORTED) {            stopSelf();        } else if (errType == SsdkUnsupportedException.LIBRARY_NOT_INSTALLED) {            Log.e(TAG, "You need to install Samsung Accessory SDK to use this application.");        } else if (errType == SsdkUnsupportedException.LIBRARY_UPDATE_IS_REQUIRED) {            Log.e(TAG, "You need to update Samsung Accessory SDK to use this application.");        } else if (errType == SsdkUnsupportedException.LIBRARY_UPDATE_IS_RECOMMENDED) {            Log.e(TAG, "We recommend that you update your Samsung Accessory SDK before using this application.");            ;            return false;        }        return true;    }    private void onDataAvailableonChannel(final GalleryProviderConnection connection, final long channelId, final String data) {        mBackgroundHandler.post(new Runnable() {            @Override            public void run() {                if (data.contains(Model.THUMBNAIL_LIST_REQ)) {                    try {                        sendThumbnails(connection, data);                    } catch (ExecutionException e) {                        e.printStackTrace();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                } else if (data.contains(Model.DOWNSCALE_IMG_REQ)) {                    try {                        sendDownscaledImage(connection, data);                    } catch (ExecutionException e) {                        e.printStackTrace();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        });    }    private void publishMediaStoreInfo(Cursor imageCursor) {        for (int j = 0; j < imageCursor.getCount(); j++) {            imageCursor.moveToNext();        }        imageCursor.moveToFirst();    }    private boolean pullThumbnails(Cursor imageCursor, int count) throws ExecutionException, InterruptedException {        String data = "";        Bitmap bm = Glide. with(this). load(featured.get(count).getImageUrl()). asBitmap().into(100, 100). get();        Matrix matrix = new Matrix();        matrix.postRotate(-90);        Bitmap scaledBitmap = Bitmap.createScaledBitmap(bm, 100, 100 ,true);        Bitmap rotatedBitmap = Bitmap.createBitmap(scaledBitmap, 0, 0, scaledBitmap.getWidth(), scaledBitmap.getHeight(), matrix, true);        if (bm == null) {            return false;        }        final ByteArrayOutputStream stream = new ByteArrayOutputStream();        rotatedBitmap.compress(Bitmap.CompressFormat.JPEG, 80, stream);        data = Base64.encodeToString(stream.toByteArray(), Base64.NO_WRAP);        try {            stream.close();        } catch (final IOException e) {            e.printStackTrace();        }        Sizes.add(rotatedBitmap.getByteCount());        final int width = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media.WIDTH));        final int height = imageCursor.getInt(imageCursor.getColumnIndex(MediaStore.Images.Media.HEIGHT));        final TBModelJson msg = new TBModelJson(count, featured.get(count).getName(), data, rotatedBitmap.getByteCount(), width, height);        mTb.add(msg);        return true;    }    private void sendThumbnails(final GalleryProviderConnection connection, String request) throws ExecutionException, InterruptedException {        boolean ret = true;        mResult = "failure";        mReason = REASON_IMAGE_ID_INVALID;        final int[] count = {0};        if (!mTb.isEmpty()) {            mTb.clear();        }        JSONObject obj = null;        try {            obj = new JSONObject(request);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final TBListReqMsg uRequest = new TBListReqMsg();        try {            uRequest.fromJSON(obj);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final long id = uRequest.getID();        final Cursor imageCursor = getContentResolver().query(                    MediaStore.Images.Media.EXTERNAL_CONTENT_URI, mProjection, null, null, null);        if (imageCursor == null) {            mReason = REASON_DATABASE_ERROR;            sendTbListMsg(connection);            return;        }        imageCursor.moveToFirst();        publishMediaStoreInfo(imageCursor);        if (id != INITIAL_IMAGE_INDEX) {            for (int i = 0; i < imageCursor.getCount(); i++) {                if (id == imageCursor.getInt(imageCursor                            .getColumnIndex(MediaStore.Images.Media._ID))) {                    ret = imageCursor.moveToNext();                    break;                }                if (imageCursor.moveToNext() == false) {                    ret = false;                    break;                }            }        }        final boolean finalRet = ret;        AsyncTaskCompat.executeParallel(new AsyncTask<Void, Void, String>() {            @Override            protected String doInBackground(Void... params) {                try {                    Utilities.webServiceCall(Constants.HostAddress + "/Api/GetFeatured?apiToken=" + Constants.ApiKey, featured);                    final int size = imageCursor.getCount();                    if ((finalRet == true) && (size > 0)) {                        do {                            boolean status = false;                            try {                                status = pullThumbnails(imageCursor, count[0]);                            } catch (ExecutionException e) {                                e.printStackTrace();                            } catch (InterruptedException e) {                                e.printStackTrace();                            }                            if (status == true) {                                count[0]++;                            }                        } while (count[0] < 4 && imageCursor.moveToNext());                        mResult = "success";                        mReason = REASON_OK;                        return "success";                    } // check to ignore in case id is last record in DB                    else {                        mReason = REASON_EOF_IMAGE;                    }                    if (!imageCursor.isClosed()) {                        imageCursor.close();                    }                } catch (Exception e) {                    return "Failed";                }                return null;            }            @Override            protected void onPostExecute(String result) {                sendTbListMsg(connection);            }        });    }    private void sendTbListMsg(GalleryProviderConnection connection) {        final TBListRespMsg uRMessage = new TBListRespMsg(mResult, mReason, mTb.size(), mTb);        String uJsonStringToSend = "";        try {            uJsonStringToSend = uRMessage.toJSON().toString();        } catch (final JSONException e) {            e.printStackTrace();        }        if (mConnectionsMap != null) {            try {                connection.send(GALLERY_CHANNEL_ID, uJsonStringToSend.getBytes());            } catch (final IOException e) {                e.printStackTrace();            }        }    }    private void sendDownscaledImage(GalleryProviderConnection connection, String request) throws ExecutionException, InterruptedException {        mImgData = "";        mResult = "failure";        mReason = REASON_IMAGE_ID_INVALID;        int orgWidth = 0, orgHeight = 0;        long orgSize = 0;        String orgName = "";        JSONObject obj = null;        String[] Values = request.split(",");        Values[1] = Values[1].replace(" \"id\" : ","");        int ids = Integer.parseInt(Values[1]);        Log.d(TAG, "sendDownscaledImage: " + ids);        try {            obj = new JSONObject(request);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final ImgReqMsg uMessage = new ImgReqMsg();        try {            uMessage.fromJSON(obj);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final long id = uMessage.getID();        pullDownscaledImg(ids);        orgWidth = 320 ;        orgHeight = 320 ;        orgName = featured.get(ids).getName();        pullDownscaledImg(ids);        sendImgRsp(connection, id, orgName, orgSize, orgWidth, orgHeight,ids);    }    private void sendImgRsp(GalleryProviderConnection connection, long id, String orgName, long orgSize, int orgWidth, int orgHeight, int index) throws ExecutionException, InterruptedException {        final TBModelJson msg = new TBModelJson(id, orgName, mImgData, Sizes.get(0), orgWidth, orgHeight);        final ImgRespMsg uresponse = new ImgRespMsg(mResult, mReason, msg);        String uJsonStringToSend = "";        try {            uJsonStringToSend = uresponse.toJSON().toString();        } catch (final JSONException e) {            e.printStackTrace();        }        if (mConnectionsMap != null) {            try {                connection.send(GALLERY_CHANNEL_ID, uJsonStringToSend.getBytes());            } catch (final IOException e) {                e.printStackTrace();            }        }    }    private void pullDownscaledImg(int index) throws ExecutionException, InterruptedException {        final BitmapFactory.Options opt = new BitmapFactory.Options();        opt.inScaled = false;        opt.inSampleSize = 4; // logic based on original and requested size.        Log.d(TAG, "sendDownscaledImage: " + featured.get(index).getImageUrl());        Bitmap bm = Glide. with(this). load(featured.get(index).getImageUrl()). asBitmap().into(240, 240). get();        Matrix matrix = new Matrix();        matrix.postRotate(-90);        Bitmap scaledBitmap = Bitmap.createScaledBitmap(bm, 240, 240 ,true);        Bitmap rotatedBitmap = Bitmap.createBitmap(scaledBitmap, 0, 0, scaledBitmap.getWidth(), scaledBitmap.getHeight(), matrix, true);        Sizes.set(0, bm.getByteCount());        if (bm != null) {            final ByteArrayOutputStream stream = new ByteArrayOutputStream();            rotatedBitmap.compress(Bitmap.CompressFormat.JPEG, 80, stream);            mImgData = Base64.encodeToString(stream.toByteArray(), Base64.NO_WRAP);            try {                stream.close();            } catch (final IOException e) {                e.printStackTrace();            }        }        mResult = "success"; // success        mReason = REASON_OK; // ok    }    public class LocalBinder extends Binder {        public GalleryProviderService getService() {            return GalleryProviderService.this;        }    }    public class GalleryProviderConnection extends SASocket {        public static final String TAG = "GalleryProviderConnection";        private int mConnectionId;        public GalleryProviderConnection() {            super(GalleryProviderConnection.class.getName());        }        @Override        public void onReceive(int channelId, byte[] data) {            final String strToUpdateUI = new String(data);            Log.d("TEST", "onReceive: " + strToUpdateUI);            onDataAvailableonChannel(this, channelId, strToUpdateUI);        }        @Override        public void onError(int channelId, String errorString, int error) {        }        @Override        public void onServiceConnectionLost(int errorCode) {            if (mConnectionsMap != null) {                mConnectionsMap.remove(mConnectionId);                mBackgroundHandler.post(new Runnable() {                    @Override                    public void run() {                        Toast.makeText(getBaseContext(), "disconnected", Toast.LENGTH_SHORT).show();                    }                });            }        }    }}